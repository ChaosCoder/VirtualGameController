// Generated by Apple Swift version 2.1 (swiftlang-700.1.101.6 clang-700.1.76)
#pragma clang diagnostic push

#if defined(__has_include) && __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <objc/NSObject.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if defined(__has_include) && __has_include(<uchar.h>)
# include <uchar.h>
#elif !defined(__cplusplus) || __cplusplus < 201103L
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
#endif

typedef struct _NSZone NSZone;

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif

#if defined(__has_attribute) && __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if defined(__has_attribute) && __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if defined(__has_attribute) && __has_attribute(objc_subclassing_restricted) 
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if defined(__has_attribute) && __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name) enum _name : _type _name; enum SWIFT_ENUM_EXTRA _name : _type
#endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
#if defined(__has_feature) && __has_feature(modules)
@import ObjectiveC;
@import Foundation;
@import Foundation.NSURLSession;
@import WatchConnectivity;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"


/// Element is a class that represents each element/control on a controller, such as Button A or dpad. Along with describing the controller element in terms of name and data type,and providing a unique identifier used when transmitting values, an element functions as the backing store that allows for multiple profiles to share the same underlying data set.  For example, because the Gamepad profile is a subset of the Extended Gamepad, the element provides the basis for providing access to values through both profile interfaces for the same controller.
///
/// \param type ElementType enumerates the standard set of controller elements, plus a few system-
/// related elements, DeviceInfoElement, SystemMessage and Custom.
///
/// \param dataType Currently three data types are supported, .String, .Int, and .Float, enumerated
/// in ElementDataType.
///
/// \param name Human-readable name for the element.
///
/// \param value The canonical value for the element.
///
/// \param getterKeypath Path to the VgcController class interface for getting the value of the element.
///
/// \param setterKeypath Path to the VgcController class interface for triggering the developer-defined
/// handlers for the element.
///
/// \param identifier A unique integer indentifier used to identify the element a value belongs to
/// when transmitting the value over the network.
///
/// \param mappingComplete A state management value used as a part of the peripheral-side element mapping system.
SWIFT_CLASS("_TtC28VirtualGameControllerWatchOS7Element")
@interface Element : NSObject
@property (nonatomic, copy) NSString * __nonnull name;
@property (nonatomic, strong) id __nonnull value;
@property (nonatomic, copy) NSString * __nonnull getterKeypath;
@property (nonatomic, copy) NSString * __nonnull setterKeypath;
@end

@class NSCoder;

SWIFT_CLASS("_TtC28VirtualGameControllerWatchOS13CustomElement")
@interface CustomElement : Element
- (nonnull instancetype)initWithCoder:(NSCoder * __nonnull)decoder;
@end


SWIFT_CLASS("_TtC28VirtualGameControllerWatchOS24CustomElementsSuperclass")
@interface CustomElementsSuperclass : NSObject
@property (nonatomic, copy) NSArray<Element *> * __nonnull customProfileElements;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS("_TtC28VirtualGameControllerWatchOS24CustomMappingsSuperclass")
@interface CustomMappingsSuperclass : NSObject
@property (nonatomic, copy) NSDictionary<NSNumber *, NSNumber *> * __nonnull mappings;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end



/// DeviceInfo contains key properties of a controller, either hardware or software.
///
/// \param deviceUID Unique identifier for the controller.  Hardware controllers have this built-in.  An arbitrary identifier can be given to a software controller, and the NSUUID().UUIDString function is recommended.
///
/// \param vendorName Built-in to a hardware controller.  For software controllers, either define a name or use an empty string "" and the machine/device name will be used.
///
/// \param profileType Built-in to a hardware controller.  This can be aribtrarily set to either extendedGamepad or Gamepad for a software controller, and will determine what elements are available to the controller.  microGamepad is only available in the tvOS context and is untested with software controllers.
///
/// \param supportsMotion Built-in parameter with a hardware controller (the Apple TV remote is the only hardware controller known to support motion). This can be set when defining a software controller, but would be overriden on the basis of the availabiity of Core Motion.  For example, an OSX-based software controller would report supports motion as false.
SWIFT_CLASS("_TtC28VirtualGameControllerWatchOS10DeviceInfo")
@interface DeviceInfo : NSObject <NSCoding>
@property (nonatomic, copy) NSString * __nonnull deviceUID;
@property (nonatomic, copy) NSString * __nonnull vendorName;
@property (nonatomic) BOOL attachedToDevice;
@property (nonatomic) BOOL supportsMotion;
@property (nonatomic, readonly, copy) NSString * __nonnull description;
- (nonnull instancetype)initWithCoder:(NSCoder * __nonnull)decoder;
- (void)encodeWithCoder:(NSCoder * __nonnull)coder;
- (id __nonnull)copyWithZone:(NSZone * __null_unspecified)zone;
@end




/// The Elements class describes the full population of controller controls, as well as providing definitions of the population of elements for each profile type.
SWIFT_CLASS("_TtC28VirtualGameControllerWatchOS8Elements")
@interface Elements : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic, copy) NSArray<Element *> * __nonnull systemElements;
@property (nonatomic, copy) NSArray<Element *> * __nonnull extendedGamepadProfileElements;
@property (nonatomic, copy) NSArray<Element *> * __nonnull gamepadProfileElements;
@property (nonatomic, copy) NSArray<Element *> * __nonnull microGamepadProfileElements;
@property (nonatomic, copy) NSArray<Element *> * __nonnull motionProfileElements;
@property (nonatomic, copy) NSArray<Element *> * __nonnull watchProfileElements;
+ (CustomElementsSuperclass * __null_unspecified)customElements;
+ (void)setCustomElements:(CustomElementsSuperclass * __null_unspecified)value;
+ (CustomMappingsSuperclass * __null_unspecified)customMappings;
+ (void)setCustomMappings:(CustomMappingsSuperclass * __null_unspecified)value;
@property (nonatomic, copy) NSDictionary<NSNumber *, Element *> * __nonnull custom;
@property (nonatomic, copy) NSArray<Element *> * __nonnull customProfileElements;
- (NSArray<Element *> * __nonnull)allElementsCollection;
@property (nonatomic, strong) Element * __nonnull systemMessage;
@property (nonatomic, strong) Element * __nonnull deviceInfoElement;
@property (nonatomic, strong) Element * __nonnull playerIndex;
@property (nonatomic, strong) Element * __nonnull pauseButton;
@property (nonatomic, strong) Element * __nonnull leftShoulder;
@property (nonatomic, strong) Element * __nonnull rightShoulder;
@property (nonatomic, strong) Element * __nonnull dpadXAxis;
@property (nonatomic, strong) Element * __nonnull dpadYAxis;
@property (nonatomic, strong) Element * __nonnull buttonA;
@property (nonatomic, strong) Element * __nonnull buttonB;
@property (nonatomic, strong) Element * __nonnull buttonX;
@property (nonatomic, strong) Element * __nonnull buttonY;
@property (nonatomic, strong) Element * __nonnull leftThumbstickXAxis;
@property (nonatomic, strong) Element * __nonnull leftThumbstickYAxis;
@property (nonatomic, strong) Element * __nonnull rightThumbstickXAxis;
@property (nonatomic, strong) Element * __nonnull rightThumbstickYAxis;
@property (nonatomic, strong) Element * __nonnull rightTrigger;
@property (nonatomic, strong) Element * __nonnull leftTrigger;
@property (nonatomic, strong) Element * __nonnull motionUserAccelerationX;
@property (nonatomic, strong) Element * __nonnull motionUserAccelerationY;
@property (nonatomic, strong) Element * __nonnull motionUserAccelerationZ;
@property (nonatomic, strong) Element * __nonnull motionRotationRateX;
@property (nonatomic, strong) Element * __nonnull motionRotationRateY;
@property (nonatomic, strong) Element * __nonnull motionRotationRateZ;
@property (nonatomic, strong) Element * __nonnull motionGravityX;
@property (nonatomic, strong) Element * __nonnull motionGravityY;
@property (nonatomic, strong) Element * __nonnull motionGravityZ;
@property (nonatomic, strong) Element * __nonnull motionAttitudeX;
@property (nonatomic, strong) Element * __nonnull motionAttitudeY;
@property (nonatomic, strong) Element * __nonnull motionAttitudeZ;
@property (nonatomic, strong) Element * __nonnull motionAttitudeW;
- (Element * __null_unspecified)elementFromIdentifier:(NSInteger)identifier;
@end


SWIFT_CLASS("_TtC28VirtualGameControllerWatchOS10VgcManager")
@interface VgcManager : NSObject
+ (VgcManager * __nonnull)sharedInstance;

/// Shared set of elements (in contrast to controllers on a Central/Bridge, each of which have their own set of elements).
+ (Elements * __nonnull)elements;
+ (void)setElements:(Elements * __nonnull)value;

/// Used as a component of the bonjour names for the various app types. This should be set to something that uniquely identifies your app.
+ (NSString * __nonnull)appIdentifier;
+ (void)setAppIdentifier:(NSString * __nonnull)value;
+ (NSString * __nonnull)bonjourTypeCentral;
+ (NSString * __nonnull)bonjourTypeBridge;

/// An app in Bridge mode can call it's handlers or simply relay data forward to the Central.  Relaying is more performant.
+ (BOOL)bridgeRelayOnly;
+ (void)setBridgeRelayOnly:(BOOL)value;

/// We support mapping from either the Peripheral or Central side.  Central-side mapping is recommended; it is more efficient because two values do not need to be transmitted. Central-side mapping also works with hardware controllers.
+ (BOOL)usePeripheralSideMapping;
+ (void)setUsePeripheralSideMapping:(BOOL)value;
+ (NSInteger)netServiceBufferSize;
+ (void)setNetServiceBufferSize:(NSInteger)value;

/// Don't enable these unless they are really needed because they produce tons of data to be transmitted and clog the channels.
+ (BOOL)enableMotionUserAcceleration;
+ (void)setEnableMotionUserAcceleration:(BOOL)value;
+ (BOOL)enableMotionRotationRate;
+ (void)setEnableMotionRotationRate:(BOOL)value;
+ (BOOL)enableMotionAttitude;
+ (void)setEnableMotionAttitude:(BOOL)value;
+ (BOOL)enableMotionGravity;
+ (void)setEnableMotionGravity:(BOOL)value;

/// Logs measurements of mesages transmitted/received and displays in console
+ (BOOL)performanceSamplingEnabled;

/// Controls how long we wait before averaging the number of messages transmitted/received per second when logging performance.  Set to 0 to disable.
+ (float)performanceSamplingDisplayFrequency;
+ (void)setPerformanceSamplingDisplayFrequency:(float)value;
@end

@class VgcWatchConnectivity;
@class CMMotionManager;

SWIFT_CLASS("_TtC28VirtualGameControllerWatchOS16VgcMotionManager")
@interface VgcMotionManager : NSObject
@property (nonatomic, strong) VgcWatchConnectivity * __null_unspecified watchConnectivity;
@property (nonatomic, readonly, strong) CMMotionManager * __nonnull manager;
@property (nonatomic) BOOL active;

/// System can handle 60 updates/sec but only if a subset of motion factors are enabled, not all four.  If all four inputs are needed, update frequency should be reduced.
@property (nonatomic) double updateInterval;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (void)start;
- (void)stop;
- (void)sendElementState:(Element * __nonnull)element;
@end

@class WCSession;
@class NSURLSession;

SWIFT_CLASS("_TtC28VirtualGameControllerWatchOS20VgcWatchConnectivity")
@interface VgcWatchConnectivity : NSObject <NSURLSessionDelegate, WCSessionDelegate>
@property (nonatomic, readonly, strong) Elements * __nonnull elements;
@property (nonatomic, strong) WCSession * __null_unspecified session;
@property (nonatomic, strong) NSURLSession * __null_unspecified httpSession;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (void)sendElementValueToBridge:(Element * __nonnull)element;
@end

#pragma clang diagnostic pop
